<#@ template language="C#" #>
<#@ Assembly Name="System.Core.dll" #>
<#@ Assembly Name="System.Net.Http.dll" #>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Globalization" #>
<#@ import namespace="System.Net.Http" #>
<#@ import namespace="System.Text" #>
<#
    const int asciiMaxCodePoint = 127;
    int year = DateTime.Now.Year;

#>#region © Copyright Web Applications (UK) Ltd, <#=year#>.  All rights reserved.
// Copyright (c) <#=year#>, Web Applications UK Ltd
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Web Applications UK Ltd nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL WEB APPLICATIONS UK LTD BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#endregion

using System.Runtime.CompilerServices;
using WebApplications.Utilities.Annotations;

namespace WebApplications.Utilities.Text
{
    // AUTO-GENERATED - DO NOT MODIFY
    // This file is generated by text template by directly downloading the Unicode property definitions.
    public static partial class TextExtensions
    {
        /// <summary>
        /// The ASCII maximum code point.
        /// </summary>
        private const int AsciiMaxCodePoint = <#=asciiMaxCodePoint#>;
<#
    LoadCharacterDatabase(new Uri("http://www.unicode.org/Public/UCD/latest/ucd/auxiliary/GraphemeBreakProperty.txt"), "Grapheme", asciiMaxCodePoint);
    LoadCharacterDatabase(new Uri("http://www.unicode.org/Public/UCD/latest/ucd/auxiliary/WordBreakProperty.txt"), "Word", asciiMaxCodePoint);
    LoadCharacterDatabase(new Uri("http://www.unicode.org/Public/UCD/latest/ucd/LineBreak.txt"), "Line", asciiMaxCodePoint);
    LoadCharacterDatabase(new Uri("http://www.unicode.org/Public/UCD/latest/ucd/auxiliary/SentenceBreakProperty.txt"), "Sentence", asciiMaxCodePoint);
#>
    }
}
<#+
void LoadCharacterDatabase(Uri databaseUri, string name, int asciiMaxCodePoint)
    {
        List<CodePoint> codePoints = new List<CodePoint>();
        int merged = 0;

        string lowerName = char.ToLower(name[0]) + name.Substring(1);
        string enumName = $"{name}Property";
        string codePointsName = $"_{lowerName}CodePoints";
        string asciiIndexName = $"_{lowerName}AsciiMaxCodePoint";

        Dictionary<string, int> nameLookup = new Dictionary<string, int>();
        List<string> names = new List<string>();

        using (HttpClient client = new HttpClient())
        {
            using (Stream downloader = client.GetStreamAsync(databaseUri).Result)
            {
                using (StreamReader reader = new StreamReader(downloader))
                {
                    StringBuilder builder = new StringBuilder(10);
                    string line;
                    int lineNum = 0;
                    CodePoint codePoint = null;

                    while ((line = reader.ReadLine()) != null)
                    {
                        lineNum++;
                        int state = 0;
                        int start = -1;
                        int end = -1;
                        int position = 0;
                        builder.Clear();
                        foreach (char c in line)
                        {
                            position++;
                            // Comments end line
                            if (c == '#')
                                break;

                            // Skip whitespace
                            if (char.IsWhiteSpace(c)) continue;

                            switch (state)
                            {
                                case 0:
                                case 2:
                                    // Reading character
                                    if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F'))
                                    {
                                        builder.Append(c);
                                        continue;
                                    }
                                    if (c == ';') state = 3;
                                    else if ((state == 0) && (c == '.')) state = 1;
                                    else
                                        throw new InvalidOperationException(
                                            $"Unexpected character '{c}' on line '{lineNum}' position '{position}'.");

                                    string charHex = builder.ToString();
                                    builder.Clear();
                                    int cint;
                                    if (charHex.Length > 6 || !int.TryParse(
                                            charHex,
                                            NumberStyles.AllowHexSpecifier,
                                            null,
                                            out cint))
                                        throw new InvalidOperationException(
                                            $"Invalid hex character reference '{charHex}' on line '{lineNum}' position '{position}'.");

                                    if (start < 1) start = cint;
                                    end = cint;
                                    break;
                                case 1:
                                    // Expecting another '.'
                                    if (c != '.')
                                        throw new InvalidOperationException(
                                            $"Expected '.' on line '{lineNum}' position '{position}'.");
                                    state = 2;
                                    break;
                                case 3:
                                    // Expecting name
                                    builder.Append(c);
                                    break;
                            }
                        }

                        // If we didn't get a start we had an empty/comment line.
                        if (start < 0) continue;

                        string propertyName = builder.ToString();

                        // Find or create an index for name.
                        int nameIndex;
                        if (!nameLookup.TryGetValue(propertyName, out nameIndex))
                        {
                            nameIndex = names.Count;
                            nameLookup.Add(propertyName, nameIndex);
                            names.Add(propertyName);
                        }

                        if (start > end)
                            throw new InvalidOperationException(
                                $"The start '{start:X}' is greater than the end '{end:X}' on line '{lineNum}'.");

                        // Merge overlaps/adjacencies
                        if (codePoint?.Merge(nameIndex, start, end, lineNum) == true)
                        {
                            merged++;
                            continue;
                        }

                        codePoint = new CodePoint(nameIndex, start, end);
                        codePoints.Add(codePoint);
                    }
                }
            }

        }

        DateTime generatedAt = DateTime.Now;
#>

        #region <#=name #>
        /// <summary>
        /// Gets the <see cref="<#=enumName #>"/> for a given unicode character.
        /// </summary>
        /// <param name="character">The unicode character.</param>
        /// <returns>The corresponding <see cref="<#=enumName #>"/>.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#=enumName #> Get<#=enumName #>(this char character)
            => BinarySearchCodePoints(
                character,
                <#=codePointsName #>,
                <#=asciiIndexName #>,
                <#=enumName #>.Any);

        /// <summary>
        /// The <#=enumName #> enumeration as,
        /// as loaded from <see href="<#=databaseUri #>"/> on <#=generatedAt #>.
        /// </summary>
        public enum <#=enumName #>
        {<#+
        for (int i = 0; i < names.Count; i++)
        {
            string enumProp = names[i];
            #><#=i > 0 ? "," : string.Empty #>
            /// <summary>
            /// The <#=enumProp #> property.
            /// </summary>
            <#=enumProp #> = <#=i #><#+
        }
        #>,
            /// <summary>
            /// The Any property.
            /// </summary>
            Any = <#=names.Count #>
        }

        /// <summary>
        /// The unicode code points, and their corresponding <see cref="<#=enumName #>"/>,
        /// as loaded from <see href="<#=databaseUri #>"/> on <#=generatedAt #>.
        /// </summary>
        /// <remarks><para>Each code point is a set of 3 integers, indicating the start of range, end of range and <see cref="<#=enumName #>"/>
        /// (represented as an <see cref="int"/>) respectively.</para>
        /// <para>There are a total of <#=codePoints.Count #> code points, merged down from <#=codePoints.Count + merged #>.</para>
        /// </remarks>
        [NotNull]
        private static readonly int[] <#=codePointsName #> = {<#+
        bool first = true;
        int asciiIndex = -1;
        foreach (CodePoint codePoint in codePoints.OrderBy(c => c.Start))
        {
            // Update the asciiIndex is this range is <= asciiMaxCodePoint
            if (codePoint.Start <= asciiMaxCodePoint)
                asciiIndex++;

            #><#=first ? string.Empty : "," #>
            <#=codePoint.Start #>,<#=codePoint.End #>,<#=codePoint.NameIndex #><#+
            first = false;
        }
        

        if (asciiIndex < 0)
            throw new InvalidOperationException($"The properties collection for {name} contained no valid code points below {asciiMaxCodePoint} - the binary search relies on at least one.");
        #>};
        
        /// <summary>
        /// The ASCII maximum code point for <#=codePointsName #>.
        /// </summary>
        private const int <#=asciiIndexName#> = <#=asciiIndex#>;
        #endregion
<#+
    }

    // Temporary store for code points  
    public class CodePoint
    {
        public int NameIndex;
        public int Start;
        public int End;

        public CodePoint(int nameIndex, int start, int end)
        {
            NameIndex = nameIndex;
            Start = start;
            End = end;
        }

        public bool Merge(int nameIndex, int start, int end, int lineNum)
        {
            if (nameIndex != NameIndex
                || (start > End + 1)) return false;

            if (start < Start)
                throw new InvalidOperationException(
                    $"The start '{start:X}' on line '{lineNum}' is less than the start '{Start:X}' on the previous line.");

            if (end < End)
                throw new InvalidOperationException(
                    $"The end '{end:X}' on line '{lineNum}' is less than the end '{End:X}' on the previous line.");

            End = end;
            return true;
        }
    }
#>